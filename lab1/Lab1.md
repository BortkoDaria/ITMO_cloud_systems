# Отчет по первой лабораторной работе
## 1. Немного о том, что такое контейнеризация и причем тут Docker

Контейнеризация - это технология, которая помогает запускать приложения изолированно от основной операционной системы. Программный код упаковывается в единый исполняемый файл вместе со всеми зависимостями и библиотеками, что позволяет свести к минимуму проблемы из серии "работает на одном устройстве, но не работает на другом". Контейнер делит с хостом ядро, пространство памяти ядра, но пользовательское окружение у контейнера свое.

Контейнеры - это более легковесное решение, чем использование виртуальных машин. Контейнеры быстрее разворачиваются, занимают меньше места в хранилище, позволяют повысить производительность разработки и дают многие другие возможности, хотя не обходится и без минусов.
Технология используется для построения архитектуры микросервисов, автоматизации разворачивания приложений на различных хостах, переноса программ в более современные среды и т. д.  

Docker - одна из наиболее популярных программных платформ для разработки, доставки и запуска контейнерных приложений. Docker позволяет создавать контейнеры, автоматизировать их запуск и развертывание, управлять их жизненным циклом. Также он позволяет запускать множество контейнеров на одной хост-машине.

## 2. Как запаковать приложение в контейнер

Dockerfile - набор инструкций, следуя которым Docker будет собирать образ контейнера. В нем указываются все программы, зависимости и образы, которые нужны для разворачивания образа. 
Файл буквально состоит из множества "слоев" с инструкцияим - что откуда взять, куда положить, где и когда запустить.
Как правило, Dockerfile начинается с инструкции FROM, задающей родительский образ, используемый для нашего собственного образа. Затем следуют прочие инструкции RUN, COPY, ADD и пр.

## 3. Плохие практики при написании Dockerfile
1. Используем тег latest при выборе родительского образа. Чем новее - тем лучше, верно? 
    Почему это плохо: однажды базовый образ обновится и перестанет быть совместимым с прочими зависимостями, прописанными в нашем образе - у нас все упадет. Переход на новые версии родительского образа должен быть контролируемым.  
2. Работаем под root'ом. Зачем нам лишние пользователи, если и так все работает
    Это плохо, потому что использование root'a создает намного больше уязвимостей, чем использование пользователя с сильно урезанными правами. Это не так критично, если приложение локальное, нет проброса портов и работы с важными данными, но становится серьезной проблемой в сложных системах, оперирующих конфиденциальными данными, или в бизнес-приложениях, падение которых приводит значительным материальным потерям
3. Разбиваем установку всех зависимостей на отдельные RUN'ы. Чем больше слоев - тем лучше
    Каждый наш RUN создает отдельный слой в образе. Чем больше слоев, тем больше весит итоговый образ и тем больше времени требуется на его сборку. Утяжеляя образ, мы невелируем одно из основных преимуществ контейнеризации - легковесность.
4. Чем больше зависимостей - тем лучше: добавим все, что нужно и еще немного про запас.
    Та же проблема, что и в предыдущем пункте: много зависимостей = тяжелый образ. К тому же, чем больше у нас зависимостей, тем сложнее поддерживать их совместимость при обновлении версий.
5. Обязательно комментируем все свои действия. 
    Нет необходимости комментировать что-то очевидное

Вообще, нет предела совершенству и Dockerfile можно сделать просто отвратительным, но не будем углубляться в плохие практики.

Для сборки образа используем команду: 
*docker build -t bad-image -f ./dockerfiles/bad.Dockerfile .* 

Образ, собираемый по "плохому" докерфайлу, строился достаточно долго, его вес тоже оставляет желать лучшего. Результат сборки образа:
![Плохой образ](/img/bad-image.jpg)
![Плохой контейнер](/img/bad-cont.jpg)

## 4. Хорошие практики при написании Dockerfile
1. Родительский образ - с точной версией и необходимым минимумом ПО
2. Везде, где не нужен root, работаем под обычным пользователем. Незачем давать полные права приложению, которому они не нужны
3. Команды логически группируются, количество слоев сводится к необходимому минимуму (но без фанатизма)
4. Ставим только необходимые на данный момент зависимости. Если нам когда-нибудь потребуется что-то еще - мы добавим это потом, сейчас оно точно лишнее.

И многое, многое другое: только уместные комментарии в файле, грамотный перенос строк для повышения читабельности кода, забота о безопасности конфиденциальных данных, правильный порядок инструкций и т. д. Предела совершенству все еще нет, но возьмем за основу два высказывания: "Хороший образ - легкий образ" и "Хороший Dockerfile - лаконичный, но читабельный".

Образ собирался ощутимо быстрее, чем в прошлом варианте, весит он также меньше, чем его "плохой" собрат. Результат сборки образа:
![Нормальный образ](/img/normal-image.jpg)
![Нормальный контейнер](/img/norm-cont.jpg)

## 5. Плохие практики использования контейнера

В этот раздел можно отнести упомянутый ранее запуск под root'ом - от имени суперпользователя должны работать только те приложения, которые иначе работать не будут. При этом должны быть приняты все возможные меры по защите информации. Если приложение может работать без root прав - оно не должно иметь root прав.

Второй плохой практикой является запуск нескольких приложений в одном контейнере - это противоречит основным принципам контейнеризации. Если мы можем разнести приложения в разные контейнеры, мы должны это сделать. 

## 6. Выводы

Что в итоге было сделано в этой лабораторной работе:
1. Проведено знакомство с технологией контейнеризации в целом и с Docker'ом в частности
2. Изучены хорошие и плохие практики написания Dockerfile
3. В двух вариантах написан собственный Dockerfile
4. Разобраны несколько плохих практик использования контейнера

Приобретенные знания полезны, изучать материал было интересно, в дальнейшем определенно пригодится.